// -- tasks --
// [x] return a basic command like "whoami"
// [ ] print out client response

#define MAX_EVENTS 10

#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

int fd_set_nonblocking(int fd) {
  // get current flags
  int flags = fcntl(fd, F_GETFL, 0);
  if (flags == -1) {
    return 1;
  }

  flags |= O_NONBLOCK;
  return fcntl(fd, F_SETFL, flags);
}

int main() {
  // -- SPIN UP THE SERVER --
  int fd_sock_server;
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;
  (void)getaddrinfo(0, "50000", &hints, &result);

  fd_sock_server =
      socket(result->ai_family, result->ai_socktype, result->ai_protocol);
  if (fd_sock_server == -1) {
    printf("[e] socket() failed: %d\n", errno);
    return 1;
  }

  if (bind(fd_sock_server, result->ai_addr, result->ai_addrlen)) {
    printf("[e] bind() failed: %d\n", errno);
    return 1;
  }

  freeaddrinfo(result);

  if (listen(fd_sock_server, 10) == -1) {
    printf("[e] listen() failed: %d\n", errno);
    return 1;
  }

  // -- MONITORING FILE DESCRIPTORS --
  int event_count;
  // event: interest list (fd that will be monitored)
  // events: ready list (set of fd that are ready for I/O)
  struct epoll_event event, events[MAX_EVENTS];

  // create fd for epoll
  int fd_epoll = epoll_create1(0);
  if (fd_epoll == -1) {
    fprintf(stderr, "[e] epoll_create1() failed: %d", errno);
    return 1;
  }

  // add server socket fd to the interest list
  event.events = EPOLLIN;         // listen for incoming connections
  event.data.fd = fd_sock_server; // associate event with server socket fd
  if (epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_sock_server, &event) == -1) {
    fprintf(stderr, "[e] epoll_ctl() failed: %d\n", errno);
    return 1;
  }

  // continous monitoring of fd
  while (1) {
    // fill the ready list with a max. of MAX_EVENTS events
    event_count = epoll_wait(fd_epoll, events, MAX_EVENTS, -1);
    if (event_count == -1) {
      fprintf(stderr, "[e] epoll_wait() failed: %d\n", errno);
      return 1;
    }

    // iterate over each event that is ready
    for (int i = 0; i < event_count; ++i) {
      // if the event is the server socket fd then a new client is trying to
      // connect
      if (events[i].data.fd == fd_sock_server) {
        struct sockaddr_storage addr_client;
        socklen_t addr_client_len = sizeof(addr_client);

        // accepting the client
        int fd_sock_client = accept(
            fd_sock_server, (struct sockaddr *)&addr_client, &addr_client_len);
        if (fd_sock_client == -1) {
          fprintf(stderr, "[e] accept() failed: %d\n", errno);
          return 1;
        }

        // set the client socket fd to non-blocking
        if (fd_set_nonblocking(fd_sock_client) == -1) {
          fprintf(stderr, "[e] fd_set_nonblocking() failed: %d\n", errno);
          return 1;
        }

        // EPOLLIN = app will be notified when data is available to read from
        // the fd
        // EPOLLOUT = app will be notified when the fd is ready to accept
        // write operations
        // EPOLLET = set edge-triggered mode -> app is only
        // notified when state of fd changes
        event.events = EPOLLIN | EPOLLOUT | EPOLLET;
        event.data.fd = fd_sock_client;
        // add client socket fd to the interest list
        if (epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_sock_client, &event) == -1) {
          fprintf(stderr, "[e] epoll_ctl() failed: %d\n", errno);
          return 1;
        }
        // read data from already connected clients
      } else if (events[i].events & EPOLLIN) {
        // recv()
        // send data to already connected clients
      } else if (events[i].events & EPOLLOUT) {
        // write()
      }
    }
  }

  return 0;
}
